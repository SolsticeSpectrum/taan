import { Colors, Spacing, BorderRadius, Animations } from "colors.slint";
import { SliderBase } from "slider-base.slint";

export component CustomSlider {
    in property <Orientation> orientation <=> base.orientation;
    in property <float> maximum <=> base.maximum;
    in property <float> minimum <=> base.minimum;
    in property <float> step <=> base.step;
    in property <bool> enabled <=> base.enabled;
    out property <bool> has-focus: base.has-focus;
    in-out property <float> value <=> base.value;

    callback changed <=> base.changed;
    callback released <=> base.released;

    min-width: base.vertical ? 20px : 0px;
    min-height: base.vertical ? 0px : 20px;
    vertical-stretch: base.vertical ? 1 : 0;
    horizontal-stretch: base.vertical ? 0 : 1;
    accessible-role: slider;
    accessible-enabled: root.enabled;
    accessible-value: root.value;
    accessible-value-minimum: root.minimum;
    accessible-value-maximum: root.maximum;
    accessible-value-step: min(root.step, (root.maximum - root.minimum) / 100);
    forward-focus: base;

    states [
        disabled when !root.enabled: {
            track.background: Colors.text-muted;
            rail.background: Colors.text-muted;
            thumb.background: Colors.text-muted;
        }
        pressed when base.handle-pressed: {
            thumb.background: Colors.slider-handle;
        }
        hover when base.has-hover: {
            thumb.background: Colors.slider-handle;
        }
    ]

    rail := Rectangle {
        x: base.vertical ? (parent.width - self.width) / 2 : thumb.width / 2;
        y: base.vertical ? thumb.height / 2 : (parent.height - self.height) / 2;
        width: base.vertical ? 3px : parent.width - thumb.width;
        height: base.vertical ? parent.height - thumb.height : 3px;
        background: Colors.slider-track;
        border-radius: BorderRadius.sm;
    }

    track := Rectangle {
        x: base.vertical ? (parent.width - self.width) / 2 : thumb.width / 2;
        y: base.vertical ? thumb.height / 2 : (parent.height - self.height) / 2;
        width: base.vertical ? rail.width : thumb.x;
        height: base.vertical ? thumb.y : rail.height;
        background: Colors.slider-fill;
        border-radius: rail.border-radius;
    }

    thumb := Rectangle {
        x: base.vertical ? (parent.width - self.width) / 2 : clamp((parent.width - self.width) * (root.value - root.minimum) / (root.maximum - root.minimum), 0, parent.width - self.width);
        y: base.vertical ? clamp((parent.height - self.height) * (root.value - root.minimum) / (root.maximum - root.minimum), 0, parent.height - self.height) : (parent.height - self.height) / 2;
        width: 14px;
        height: 14px;
        border-radius: BorderRadius.full;
        background: Colors.slider-handle;
    }

    base := SliderBase {
        width: 100%;
        height: 100%;
        handle-x: thumb.x;
        handle-y: thumb.y;
        handle-width: thumb.width;
        handle-height: thumb.height;
    }
}

// Progress bar component - specialized slider for showing progress without interaction
export component ProgressBar inherits Rectangle {
    // Properties
    in-out property <float> progress: 0.0; // Progress value (0.0 to 1.0)
    in-out property <string> current-time: "0:00";
    in-out property <string> remaining-time: "-0:00";

    // Callbacks
    callback seek(float); // Emitted when user seeks to a position
    callback moved(float); // Emitted when user is moving the slider

    height: 20px;
    HorizontalLayout {
        alignment: LayoutAlignment.stretch;
        spacing: Spacing.sm;

        // Current time
        current-time-text := Text {
            text: root.current-time;
            color: Colors.text-secondary;
            font-size: 12px;
            horizontal-alignment: left;
            min-width: 32px;
            max-width: 32px;
        }

        // Progress slider
        progress-slider := CustomSlider {
            minimum: 0.0;
            maximum: 1.0;
            value <=> root.progress;
            released(new-value) => {
                root.seek(new-value);
            }
            changed(new-value) => {
                root.moved(new-value);
            }
        }

        // Remaining time
        remaining-time-text := Text {
            text: root.remaining-time;
            color: Colors.text-secondary;
            font-size: 12px;
            horizontal-alignment: right;
            min-width: 32px;
            max-width: 32px;
        }
    }
}

// Volume slider component - specialized slider with volume icons
export component VolumeSlider inherits Rectangle {
    // Properties
    in-out property <float> volume: 0.7; // Volume value (0.0 to 1.0)

    // Callbacks
    callback volume-changed(float); // Emitted when volume changes

    height: 24px;
    HorizontalLayout {
        spacing: Spacing.md;
        alignment: stretch;
        Rectangle {
            height: parent.height;
            // Volume low icon
            volume-low-icon := Image {
                source: @image-url("../../../resources/icons/volume-1.svg");
                width: 16px;
                height: 16px;
                colorize: Colors.icon-secondary;
            }
        }

        Rectangle {
            height: parent.height;
        // Volume slider
        volume-slider := CustomSlider {
                horizontal-stretch: 1;
                minimum: 0.0;
                maximum: 1.0;
                value <=> root.volume;

                released(new-value) => {
                    root.volume-changed(new-value);
                }
            }
        }

        Rectangle {
            height: parent.height;
        // Volume high icon
        volume-high-icon := Image {
                source: @image-url("../../../resources/icons/volume-2.svg");
                width: 16px;
                height: 16px;
                colorize: Colors.icon-secondary;
            }
        }
    }
}
